/***************************************************************************
 *                                                                         *
 *    HHEDIT: Hungry Horace editor                                         *
 *    Copyright (C) 2009 John Elliott <jce@seasip.demon.co.uk>             *
 *                                                                         *
 *    This program is free software; you can redistribute it and/or modify *
 *    it under the terms of the GNU General Public License as published by *
 *    the Free Software Foundation; either version 2 of the License, or    *
 *    (at your option) any later version.                                  *
 *                                                                         *
 *    This program is distributed in the hope that it will be useful,      *
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
 *    GNU General Public License for more details.                         *
 *                                                                         *
 *    You should have received a copy of the GNU General Public License    *
 *    along with this program; if not, write to the Free Software          *
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
 *                                                                         *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <conio.h>
#include "pc_mouse.h"
#include "pc_video.h"

extern unsigned tiles(void);
extern byte peek(unsigned addr);

#define K_MOUSE (-32)

GRAPHICS gl_graphics;
int gl_mxscale = 1;
int gl_myscale = 1;
int gl_mbutton, gl_xmouse, gl_ymouse;

byte font8x8[] = 
{
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 0 */
   0x3c, 0x42, 0xa5, 0x81, 0xa5, 0x99, 0x42, 0x3c,   /* 1 */
   0x3c, 0x7e, 0xdb, 0xff, 0xdb, 0xe7, 0x7e, 0x3c,   /* 2 */
   0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,   /* 3 */
   0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,   /* 4 */
   0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0x18, 0x3c, 0x00,   /* 5 */
   0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x10, 0x38, 0x00,   /* 6 */
   0x00, 0x00, 0x08, 0x1c, 0x08, 0x00, 0x00, 0x00,   /* 7 */
   0xff, 0xff, 0xe7, 0xc3, 0xe7, 0xff, 0xff, 0xff,   /* 8 */
   0x00, 0x00, 0x18, 0x24, 0x18, 0x00, 0x00, 0x00,   /* 9 */
   0xff, 0xff, 0xe7, 0xdb, 0xe7, 0xff, 0xff, 0xff,   /* 10 */
   0x00, 0x0e, 0x06, 0x0a, 0x3c, 0x42, 0x3c, 0x00,   /* 11 */
   0x00, 0x38, 0x44, 0x38, 0x10, 0x38, 0x10, 0x00,   /* 12 */
   0x00, 0x1c, 0x18, 0x10, 0x30, 0x70, 0x20, 0x00,   /* 13 */
   0x00, 0x3e, 0x22, 0x22, 0x26, 0x64, 0x40, 0x00,   /* 14 */
   0x00, 0x54, 0x38, 0x44, 0x38, 0x54, 0x10, 0x00,   /* 15 */
   0x60, 0x78, 0x7e, 0x7f, 0x7e, 0x78, 0x60, 0x00,   /* 16 */
   0x03, 0x0f, 0x3f, 0x7f, 0x3f, 0x0f, 0x03, 0x00,   /* 17 */
   0x00, 0x08, 0x1c, 0x08, 0x08, 0x1c, 0x08, 0x00,   /* 18 */
   0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x28, 0x00,   /* 19 */
   0x00, 0x3e, 0x44, 0x44, 0x3c, 0x04, 0x04, 0x00,   /* 20 */
   0x00, 0x3c, 0x42, 0x38, 0x24, 0x1c, 0x42, 0x3c,   /* 21 */
   0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x00, 0x00,   /* 22 */
   0x00, 0x08, 0x1c, 0x08, 0x1c, 0x08, 0x3e, 0x00,   /* 23 */
   0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x00,   /* 24 */
   0x00, 0x10, 0x10, 0x10, 0x54, 0x38, 0x10, 0x00,   /* 25 */
   0x00, 0x08, 0x04, 0x7e, 0x04, 0x08, 0x00, 0x00,   /* 26 */
   0x00, 0x10, 0x20, 0x7e, 0x20, 0x10, 0x00, 0x00,   /* 27 */
   0x00, 0x00, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00,   /* 28 */
   0x00, 0x00, 0x24, 0x7e, 0x24, 0x00, 0x00, 0x00,   /* 29 */
   0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00,   /* 30 */
   0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00,   /* 31 */
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 32 */
   0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00,   /* 33 */
   0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 34 */
   0x00, 0x14, 0x7c, 0x28, 0x28, 0x7c, 0x50, 0x00,   /* 35 */
   0x00, 0x08, 0x1e, 0x28, 0x1c, 0x0a, 0x3c, 0x08,   /* 36 */
   0x00, 0x22, 0x54, 0x28, 0x14, 0x2a, 0x44, 0x00,   /* 37 */
   0x00, 0x30, 0x48, 0x32, 0x4c, 0x44, 0x3a, 0x00,   /* 38 */
   0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 39 */
   0x00, 0x04, 0x08, 0x10, 0x10, 0x08, 0x04, 0x00,   /* 40 */
   0x00, 0x10, 0x08, 0x04, 0x04, 0x08, 0x10, 0x00,   /* 41 */
   0x00, 0x24, 0x18, 0x7e, 0x18, 0x24, 0x00, 0x00,   /* 42 */
   0x00, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00,   /* 43 */
   0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x08, 0x10,   /* 44 */
   0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00,   /* 45 */
   0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,   /* 46 */
   0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00,   /* 47 */
   0x00, 0x3c, 0x42, 0x4a, 0x52, 0x42, 0x3c, 0x00,   /* 48 */
   0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x3e, 0x00,   /* 49 */
   0x00, 0x1c, 0x22, 0x02, 0x0c, 0x10, 0x3e, 0x00,   /* 50 */
   0x00, 0x7e, 0x02, 0x1c, 0x02, 0x42, 0x3c, 0x00,   /* 51 */
   0x00, 0x0c, 0x14, 0x24, 0x7e, 0x04, 0x04, 0x00,   /* 52 */
   0x00, 0x7e, 0x40, 0x7c, 0x02, 0x42, 0x3c, 0x00,   /* 53 */
   0x00, 0x1e, 0x20, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 54 */
   0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00,   /* 55 */
   0x00, 0x3c, 0x42, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 56 */
   0x00, 0x3c, 0x42, 0x3e, 0x02, 0x04, 0x38, 0x00,   /* 57 */
   0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00,   /* 58 */
   0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x08, 0x10,   /* 59 */
   0x00, 0x08, 0x10, 0x20, 0x10, 0x08, 0x00, 0x00,   /* 60 */
   0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x00, 0x00,   /* 61 */
   0x00, 0x08, 0x04, 0x02, 0x04, 0x08, 0x00, 0x00,   /* 62 */
   0x00, 0x1c, 0x22, 0x04, 0x08, 0x00, 0x08, 0x00,   /* 63 */
   0x00, 0x3c, 0x4a, 0x56, 0x4e, 0x40, 0x3c, 0x00,   /* 64 */
   0x00, 0x18, 0x24, 0x42, 0x7e, 0x42, 0x42, 0x00,   /* 65 */
   0x00, 0x78, 0x44, 0x7c, 0x42, 0x42, 0x7c, 0x00,   /* 66 */
   0x00, 0x1c, 0x22, 0x40, 0x40, 0x22, 0x1c, 0x00,   /* 67 */
   0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,   /* 68 */
   0x00, 0x7e, 0x40, 0x78, 0x40, 0x40, 0x7e, 0x00,   /* 69 */
   0x00, 0x7e, 0x40, 0x78, 0x40, 0x40, 0x40, 0x00,   /* 70 */
   0x00, 0x1c, 0x22, 0x40, 0x46, 0x22, 0x1e, 0x00,   /* 71 */
   0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00,   /* 72 */
   0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 73 */
   0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00,   /* 74 */
   0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,   /* 75 */
   0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c, 0x00,   /* 76 */
   0x00, 0x42, 0x66, 0x5a, 0x42, 0x42, 0x42, 0x00,   /* 77 */
   0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00,   /* 78 */
   0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,   /* 79 */
   0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00,   /* 80 */
   0x00, 0x18, 0x24, 0x42, 0x4a, 0x24, 0x1e, 0x00,   /* 81 */
   0x00, 0x78, 0x44, 0x44, 0x78, 0x44, 0x42, 0x00,   /* 82 */
   0x00, 0x3c, 0x42, 0x30, 0x0c, 0x42, 0x3c, 0x00,   /* 83 */
   0x00, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,   /* 84 */
   0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,   /* 85 */
   0x00, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00,   /* 86 */
   0x00, 0x44, 0x44, 0x44, 0x54, 0x54, 0x28, 0x00,   /* 87 */
   0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00,   /* 88 */
   0x00, 0x44, 0x44, 0x38, 0x10, 0x10, 0x10, 0x00,   /* 89 */
   0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00,   /* 90 */
   0x00, 0x1c, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x00,   /* 91 */
   0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00,   /* 92 */
   0x00, 0x1c, 0x04, 0x04, 0x04, 0x04, 0x1c, 0x00,   /* 93 */
   0x00, 0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00,   /* 94 */
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,   /* 95 */
   0x00, 0x0c, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00,   /* 96 */
   0x00, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 97 */
   0x00, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x7c, 0x00,   /* 98 */
   0x00, 0x00, 0x3c, 0x42, 0x40, 0x42, 0x3c, 0x00,   /* 99 */
   0x00, 0x02, 0x3e, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 100 */
   0x00, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x3c, 0x00,   /* 101 */
   0x00, 0x0e, 0x10, 0x3e, 0x10, 0x10, 0x10, 0x00,   /* 102 */
   0x00, 0x00, 0x3e, 0x42, 0x42, 0x3e, 0x02, 0x7c,   /* 103 */
   0x00, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x00,   /* 104 */
   0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 105 */
   0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x04, 0x38,   /* 106 */
   0x00, 0x20, 0x22, 0x24, 0x38, 0x24, 0x22, 0x00,   /* 107 */
   0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,   /* 108 */
   0x00, 0x00, 0x6c, 0x52, 0x52, 0x52, 0x42, 0x00,   /* 109 */
   0x00, 0x00, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x00,   /* 110 */
   0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00,   /* 111 */
   0x00, 0x00, 0x7c, 0x42, 0x42, 0x42, 0x7c, 0x40,   /* 112 */
   0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x3e, 0x02,   /* 113 */
   0x00, 0x00, 0x5c, 0x62, 0x40, 0x40, 0x40, 0x00,   /* 114 */
   0x00, 0x00, 0x1e, 0x20, 0x1c, 0x02, 0x3c, 0x00,   /* 115 */
   0x00, 0x10, 0x3e, 0x10, 0x10, 0x10, 0x0e, 0x00,   /* 116 */
   0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 117 */
   0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,   /* 118 */
   0x00, 0x00, 0x44, 0x44, 0x54, 0x54, 0x28, 0x00,   /* 119 */
   0x00, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00,   /* 120 */
   0x00, 0x00, 0x42, 0x42, 0x42, 0x3c, 0x08, 0x70,   /* 121 */
   0x00, 0x00, 0x3e, 0x04, 0x08, 0x10, 0x3e, 0x00,   /* 122 */
   0x00, 0x06, 0x08, 0x30, 0x08, 0x08, 0x06, 0x00,   /* 123 */
   0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 124 */
   0x00, 0x30, 0x08, 0x06, 0x08, 0x08, 0x30, 0x00,   /* 125 */
   0x00, 0x62, 0x92, 0x8c, 0x00, 0x00, 0x00, 0x00,   /* 126 */
   0x00, 0x18, 0x24, 0x42, 0x42, 0x42, 0x7e, 0x00,   /* 127 */
   0x00, 0x1c, 0x22, 0x40, 0x22, 0x1c, 0x04, 0x18,   /* 128 */
   0x42, 0x00, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 129 */
   0x08, 0x10, 0x3c, 0x42, 0x7e, 0x40, 0x3c, 0x00,   /* 130 */
   0x10, 0x28, 0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 131 */
   0x44, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 132 */
   0x10, 0x08, 0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 133 */
   0x18, 0x24, 0x1c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 134 */
   0x00, 0x00, 0x1e, 0x20, 0x20, 0x1e, 0x04, 0x18,   /* 135 */
   0x10, 0x28, 0x3c, 0x42, 0x7e, 0x40, 0x3c, 0x00,   /* 136 */
   0x44, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x3c, 0x00,   /* 137 */
   0x20, 0x10, 0x3c, 0x42, 0x7e, 0x40, 0x3c, 0x00,   /* 138 */
   0x22, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 139 */
   0x08, 0x14, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 140 */
   0x20, 0x10, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 141 */
   0x24, 0x00, 0x18, 0x24, 0x42, 0x7e, 0x42, 0x00,   /* 142 */
   0x38, 0x44, 0x38, 0x24, 0x42, 0x7e, 0x42, 0x00,   /* 143 */
   0x08, 0x10, 0x7e, 0x40, 0x78, 0x40, 0x7e, 0x00,   /* 144 */
   0x00, 0x00, 0x34, 0x0a, 0x3e, 0x48, 0x36, 0x00,   /* 145 */
   0x00, 0x1e, 0x28, 0x4c, 0x78, 0x48, 0x4e, 0x00,   /* 146 */
   0x38, 0x44, 0x00, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 147 */
   0x42, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 148 */
   0x10, 0x08, 0x00, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 149 */
   0x10, 0x28, 0x00, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 150 */
   0x20, 0x10, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 151 */
   0x42, 0x00, 0x42, 0x42, 0x42, 0x3c, 0x08, 0x70,   /* 152 */
   0x42, 0x18, 0x24, 0x42, 0x42, 0x24, 0x18, 0x00,   /* 153 */
   0x44, 0x00, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,   /* 154 */
   0x00, 0x04, 0x1e, 0x20, 0x20, 0x1e, 0x04, 0x00,   /* 155 */
   0x00, 0x1c, 0x20, 0x78, 0x20, 0x20, 0x7c, 0x00,   /* 156 */
   0x00, 0x22, 0x22, 0x1c, 0x08, 0x3e, 0x08, 0x00,   /* 157 */
   0x00, 0x70, 0x48, 0x7c, 0x46, 0x44, 0x46, 0x00,   /* 158 */
   0x06, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x30, 0x00,   /* 159 */
   0x08, 0x10, 0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00,   /* 160 */
   0x04, 0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 161 */
   0x08, 0x10, 0x00, 0x3c, 0x42, 0x42, 0x3c, 0x00,   /* 162 */
   0x08, 0x10, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00,   /* 163 */
   0x32, 0x4c, 0x00, 0x3c, 0x22, 0x22, 0x22, 0x00,   /* 164 */
   0x32, 0x4c, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00,   /* 165 */
   0x3c, 0x02, 0x3e, 0x42, 0x3e, 0x00, 0x7e, 0x00,   /* 166 */
   0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x7e, 0x00,   /* 167 */
   0x00, 0x10, 0x00, 0x10, 0x20, 0x22, 0x1c, 0x00,   /* 168 */
   0x00, 0x00, 0x00, 0x7c, 0x40, 0x40, 0x00, 0x00,   /* 169 */
   0x00, 0x00, 0x00, 0x7c, 0x04, 0x04, 0x00, 0x00,   /* 170 */
   0x00, 0x40, 0x5c, 0x42, 0x4c, 0x10, 0x1e, 0x00,   /* 171 */
   0x00, 0x40, 0x46, 0x4a, 0x52, 0x1e, 0x02, 0x00,   /* 172 */
   0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00,   /* 173 */
   0x00, 0x00, 0x12, 0x24, 0x48, 0x24, 0x12, 0x00,   /* 174 */
   0x00, 0x00, 0x48, 0x24, 0x12, 0x24, 0x48, 0x00,   /* 175 */
   0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,   /* 176 */
   0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,   /* 177 */
   0xbb, 0xee, 0xbb, 0xee, 0xbb, 0xee, 0xbb, 0xee,   /* 178 */
   0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,   /* 179 */
   0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18,   /* 180 */
   0x18, 0x18, 0xf8, 0x18, 0x18, 0xf8, 0x18, 0x18,   /* 181 */
   0x24, 0x24, 0x24, 0xe4, 0xe4, 0x24, 0x24, 0x24,   /* 182 */
   0x00, 0x00, 0x00, 0xfc, 0xfc, 0x24, 0x24, 0x24,   /* 183 */
   0x00, 0x00, 0xf8, 0x18, 0x18, 0xf8, 0x18, 0x18,   /* 184 */
   0x24, 0x24, 0xe4, 0x04, 0x04, 0xe4, 0x24, 0x24,   /* 185 */
   0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,   /* 186 */
   0x00, 0x00, 0xfc, 0x04, 0x04, 0xe4, 0x24, 0x24,   /* 187 */
   0x24, 0x24, 0xe4, 0x04, 0x04, 0xfc, 0x00, 0x00,   /* 188 */
   0x24, 0x24, 0x24, 0xfc, 0xfc, 0x00, 0x00, 0x00,   /* 189 */
   0x18, 0x18, 0xf8, 0x18, 0x18, 0xf8, 0x00, 0x00,   /* 190 */
   0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18,   /* 191 */
   0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00,   /* 192 */
   0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00,   /* 193 */
   0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18,   /* 194 */
   0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18,   /* 195 */
   0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,   /* 196 */
   0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18,   /* 197 */
   0x18, 0x18, 0x1f, 0x18, 0x18, 0x1f, 0x18, 0x18,   /* 198 */
   0x24, 0x24, 0x24, 0x27, 0x27, 0x24, 0x24, 0x24,   /* 199 */
   0x24, 0x24, 0x27, 0x20, 0x20, 0x3f, 0x00, 0x00,   /* 200 */
   0x00, 0x00, 0x3f, 0x20, 0x20, 0x27, 0x24, 0x24,   /* 201 */
   0x24, 0x24, 0xe7, 0x00, 0x00, 0xff, 0x00, 0x00,   /* 202 */
   0x00, 0x00, 0xff, 0x00, 0x00, 0xe7, 0x24, 0x24,   /* 203 */
   0x24, 0x24, 0x27, 0x20, 0x20, 0x27, 0x24, 0x24,   /* 204 */
   0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,   /* 205 */
   0x24, 0x24, 0xe7, 0x00, 0x00, 0xe7, 0x24, 0x24,   /* 206 */
   0x18, 0x18, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,   /* 207 */
   0x24, 0x24, 0x24, 0xff, 0xff, 0x00, 0x00, 0x00,   /* 208 */
   0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x18, 0x18,   /* 209 */
   0x00, 0x00, 0x00, 0xff, 0xff, 0x24, 0x24, 0x24,   /* 210 */
   0x24, 0x24, 0x24, 0x3f, 0x3f, 0x00, 0x00, 0x00,   /* 211 */
   0x18, 0x18, 0x1f, 0x18, 0x18, 0x1f, 0x00, 0x00,   /* 212 */
   0x00, 0x00, 0x1f, 0x18, 0x18, 0x1f, 0x18, 0x18,   /* 213 */
   0x00, 0x00, 0x00, 0x3f, 0x3f, 0x24, 0x24, 0x24,   /* 214 */
   0x24, 0x24, 0x24, 0xff, 0xff, 0x24, 0x24, 0x24,   /* 215 */
   0x18, 0x18, 0xff, 0x18, 0x18, 0xff, 0x18, 0x18,   /* 216 */
   0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00,   /* 217 */
   0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18,   /* 218 */
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,   /* 219 */
   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,   /* 220 */
   0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,   /* 221 */
   0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,   /* 222 */
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,   /* 223 */
   0x00, 0x00, 0x32, 0x4c, 0x48, 0x4c, 0x32, 0x00,   /* 224 */
   0x00, 0x3c, 0x42, 0x4c, 0x42, 0x7c, 0x40, 0x00,   /* 225 */
   0x7e, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   /* 226 */
   0x00, 0x00, 0x7e, 0x24, 0x24, 0x24, 0x22, 0x00,   /* 227 */
   0x7e, 0x20, 0x10, 0x08, 0x10, 0x20, 0x7e, 0x00,   /* 228 */
   0x00, 0x00, 0x3e, 0x48, 0x44, 0x44, 0x38, 0x00,   /* 229 */
   0x00, 0x00, 0x22, 0x22, 0x22, 0x3c, 0x20, 0x40,   /* 230 */
   0x00, 0x00, 0x7e, 0x10, 0x10, 0x10, 0x0c, 0x00,   /* 231 */
   0x1c, 0x08, 0x3e, 0x49, 0x3e, 0x08, 0x1c, 0x00,   /* 232 */
   0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x3c, 0x00,   /* 233 */
   0x3c, 0x42, 0x42, 0x42, 0x42, 0x24, 0x66, 0x00,   /* 234 */
   0x06, 0x08, 0x04, 0x3e, 0x42, 0x42, 0x3c, 0x00,   /* 235 */
   0x00, 0x00, 0x36, 0x49, 0x49, 0x36, 0x00, 0x00,   /* 236 */
   0x08, 0x08, 0x3e, 0x49, 0x49, 0x3e, 0x08, 0x08,   /* 237 */
   0x00, 0x00, 0x1c, 0x22, 0x18, 0x22, 0x1c, 0x00,   /* 238 */
   0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00,   /* 239 */
   0x00, 0x3e, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00,   /* 240 */
   0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x3e, 0x00,   /* 241 */
   0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x3e, 0x00,   /* 242 */
   0x04, 0x08, 0x10, 0x08, 0x04, 0x00, 0x3e, 0x00,   /* 243 */
   0x06, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08,   /* 244 */
   0x08, 0x08, 0x08, 0x08, 0x08, 0x48, 0x48, 0x30,   /* 245 */
   0x00, 0x08, 0x00, 0x3e, 0x00, 0x08, 0x00, 0x00,   /* 246 */
   0x00, 0x32, 0x4c, 0x00, 0x32, 0x4c, 0x00, 0x00,   /* 247 */
   0x0c, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 248 */
   0x0c, 0x1e, 0x1e, 0x0c, 0x00, 0x00, 0x00, 0x00,   /* 249 */
   0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,   /* 250 */
   0x07, 0x04, 0x04, 0x04, 0x64, 0x14, 0x0c, 0x04,   /* 251 */
   0x3c, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00,   /* 252 */
   0x1c, 0x02, 0x0c, 0x10, 0x1e, 0x00, 0x00, 0x00,   /* 253 */
   0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00,   /* 254 */
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   /* 255 */
};

unsigned *savebuf = NULL;

void savescr(void)
{
	unsigned len = 0;
	unsigned base = 0;
	unsigned far *data;
	unsigned n;

	switch(gl_graphics)
	{
		case MDA: base = 0xB000; len =  2048; break;
		case CGA: base = 0xB800; len =  8192; break;
		case VGA: base = 0xA000; len = 32000; break;
	}
	data = MK_FP(base, 0);
	for (n = 0; n < len; n++) savebuf[n] = data[n];
}


void restorescr(void)
{
	unsigned len = 0;
	unsigned base = 0;
	unsigned far *data;
	unsigned n;

	switch(gl_graphics)
	{
		case MDA: base = 0xB000; len =  2048; break;
		case CGA: base = 0xB800; len =  8192; break;
		case VGA: base = 0xA000; len = 32000; break;
	}
	data = MK_FP(base, 0);
	for (n = 0; n < len; n++) data[n] = savebuf[n];
}


byte cga_nibble[16] = { 0x00, 0x03, 0x0C, 0x0F, 
			0x30, 0x33, 0x3C, 0x3F,
			0xC0, 0xC3, 0xCC, 0xCF,
			0xF0, 0xF3, 0xFC, 0xFF, };

/* Graphics chars */
#define HLINE 0xCD
#define VLINE 0xBA
#define TLJ 0xC9
#define TRJ 0xBB
#define BLJ 0xC8
#define BRJ 0xBC
#define LJ 0xB9
#define RJ 0xCC
#define BJ 0xCB
#define TJ 0xCA
#define XROADS 0xCE
#define STOPT 0xD0
#define STOPB 0xD2
#define STOPL 0xB5
#define STOPR 0xC6

#define HLINE2 0xC4
#define VLINE2 0xB3
#define TLJ2 0xDA
#define TRJ2 0xBF
#define BLJ2 0xC0
#define BRJ2 0xD9


int getmode(void)
{
	union REGS rg;

	rg.h.ah = 0x0F;
	int86(0x10, &rg, &rg);
	return rg.h.al;
}


int setmode(int m)
{
	union REGS rg;

	rg.x.ax = m & 0xFF;
	int86(0x10, &rg, &rg);
	return (getmode() == m);
}


void setpalette(int type, int col)
{
	union REGS rg;

	rg.h.ah = 0x0B;
	rg.h.bh = type;
	rg.h.bl = col;
	int86(0x10, &rg, &rg);
}


int vga_init(void)
{
	union REGS rg;
	struct SREGS sg;

	static byte dac[] = {    0,  0,  0,   0, 0, 42,   0, 42, 0,   0,42, 42,
				42,  0,  0,  42, 0, 42,  42, 42, 0,  42,42, 42,
			 	21, 21, 21,   0, 0, 63,   0, 63, 0,   0,63, 63,
			 	63,  0,  0,  63, 0, 63,  63, 63, 0,  63,63, 63,
	};

	if (!setmode(0x13)) return 0;
	savebuf = malloc(64000);
	if (!savebuf) return 0;

	rg.x.ax = 0x1012;
	rg.x.bx = 0;
	rg.x.cx = 16;
	rg.x.dx = FP_OFF(dac);
	sg.es = FP_SEG(dac);
	int86x(0x10, &rg, &rg, &sg);
	gl_mxscale = -2;
	return 1;
}

int cga_init(void)
{
	if (!setmode(4)) return 0;
	savebuf = malloc(16384);
	if (!savebuf) return 0;
	setpalette(1, 1);
	gl_mxscale = -2;
	return 1;
}


int mda_init(void)
{
	if (!setmode(7)) return 0;
	savebuf = malloc(4096);
	if (!savebuf) return 0;
	gl_mxscale = 4;
	gl_myscale = 8;
	return 1;
}




void mda_putstr(unsigned r, unsigned c, const char *s, int len, byte at)
{
	byte far *data = MK_FP(0xB000, r * 160 + 2 * c);
	unsigned n;
	
	if (len < 0) len = strlen(s);
	for (n = 0; n < len; n++)
	{
		if (*s == 0) s = " ";
		*data++ = *s++;
		*data++ = at;
	}
}

void cga_putstr(unsigned r, unsigned c, const char *s, int len, byte rv, unsigned h)
{
	byte far *data = MK_FP(0xB800, r * 320 + c * 2);
	unsigned n, y;
	if (len < 0) len = strlen(s);

	for (n = 0; n < len; n++)
	{
		byte *ch = font8x8 + 8 * ((unsigned char)s[n]);
		unsigned off = 2 * n;

		for (y = 0; y < h; y++)
		{
			byte left  = cga_nibble[(ch[y] >> 4) & 0x0F];
			byte right = cga_nibble[ch[y] & 0x0F];
			data[off  ] = left ^ rv;
			data[off+1] = right ^ rv;
			if (y & 1) off += 80;
			off ^= 0x2000;	
		}
	}
}

void vga_putstr(unsigned r, unsigned c, const char *s, int len, byte fg, byte bg, unsigned h)
{
	byte far *data = MK_FP(0xA000, r * 2560 + c * 8);
	unsigned n, y, x;
	if (len < 0) len = strlen(s);

	for (n = 0; n < len; n++)
	{
		byte *ch = font8x8 + 8 * ((unsigned char)s[n]);

		for (y = 0; y < h; y++)
		{
			byte mask = 0x80;
			for (x = 0; x < 8; x++)
			{
				data[y*320+x] = (ch[y] & mask) ? fg : bg; 
				mask = mask >> 1;
			}
		}
		data += 8;
	}
}




void putstr(unsigned r, unsigned c, const char *s, int rv)
{
	switch(gl_graphics)
	{
		case MDA: mda_putstr(r, 2*c, s, -1, rv ? 0x70 : 15); break;
		case CGA: cga_putstr(r, c, s, -1, rv ? 255 : 0, 8); break;
		case VGA: vga_putstr(r, c, s, -1, rv ? 0 : 15, 
					  rv ? 15 : 0, 8); break;
	}
}

void iputstr(unsigned r, unsigned c, const char *s)
{
	switch(gl_graphics)
	{
		case MDA: mda_putstr(r, c, s, -1, 15); break;
		case CGA: cga_putstr(r, c, s, -1, 0xFF, 8); break;
		case VGA: vga_putstr(r, c, s, -1, 0, 15, 8); break;
	}
}

const unsigned char str_4x4[] = { 0x20, 250, 0xB0, 0xB2, 254 };
const unsigned char pcg_4x4[] = { 0xFF, 0xFF, 0xFF, 0xFF,
	                          0xFF, 0xCF, 0xFF, 0xFF,
				  0x57, 0x47, 0x57, 0xFF,
				  0xAB, 0xAB, 0xAB, 0xFF,
				  0x03, 0x03, 0x03, 0xFF };
const unsigned char pvg_4x4[] = { 0x0F, 0x0F, 0x0F, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,

				  0x0F, 0x0F, 0x0F, 0x0F,
				  0x0F, 0x00, 0x0F, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,

				  0x0B, 0x0B, 0x0B, 0x0F,
				  0x0B, 0x00, 0x0B, 0x0F,
				  0x0B, 0x0B, 0x0B, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,

				  0x0C, 0x0C, 0x0C, 0x0F,
				  0x0C, 0x0C, 0x0C, 0x0F,
				  0x0C, 0x0C, 0x0C, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,

				  0x00, 0x00, 0x00, 0x0F,
				  0x00, 0x00, 0x00, 0x0F,
				  0x00, 0x00, 0x00, 0x0F,
				  0x0F, 0x0F, 0x0F, 0x0F,
};


void cga_4x4(unsigned r, unsigned c, char pattern)
{
	unsigned char far *buf = MK_FP(0xB800, r * 160 + c);
	const unsigned char *src= &pcg_4x4[4 * pattern];

	buf[0     ] = src[0];
	buf[0x2000] = src[1];
	buf[0x50  ] = src[2];
	buf[0x2050] = src[3];
}


void vga_4x4(unsigned r, unsigned c, char pattern)
{
	int x, y;

	unsigned char far *buf = MK_FP(0xA000, r * 1280 + c*4);
	const unsigned char *src= &pvg_4x4[16 * pattern];

	for (y = 0; y < 4; y++)
	{
		for (x = 0; x < 4; x++)
		{
			buf[y * 320+x] = src[y*4 + x];
		}
	}
}

void put_4x4(unsigned r, unsigned c, char pattern)
{
	char buf[2];

	switch(gl_graphics)
	{
		case MDA: buf[0] = str_4x4[pattern];
			  buf[1] = 0;
			  mda_putstr(r, c, buf, -1, 0x70); 
			  break;
		case CGA: cga_4x4(r + 14, c, pattern);
			  break;
		case VGA: vga_4x4(r + 14, c, pattern);
			  break;
	}
}


int getkey(void)
{
//	char buf[20];
	int k = getch();

	if (k) return k;	/* Normal key */
	k = getch();
	switch(k)
	{
		/* Cursor keys -> Wordstar diamond */
		case 0x48:	return 'E' - '@';
		case 0x4b:	return 'S' - '@';
		case 0x4d:	return 'D' - '@';
		case 0x50:	return 'X' - '@';

		case 0x3b:	return '?';		/* F1 -> Help */
		case 0x3c:	return 'W' - '@';	/* F2 -> Save */
		case 0x3e:	return 'Z' - '@';	/* F4 -> Revert */
		case 0x44:	return '[' - '@';	/* F10 => ESC */
	}
//	sprintf(buf, "0x%02x", k);
//	putstr(1, 37, buf);

	return 0;
}

void debounce_mouse(void)
{
	while (1)
	{
		pc_poll_mouse(&gl_xmouse, &gl_ymouse, &gl_mbutton);
		if (!gl_mbutton) break;
		idle();
	}
}

int getevent(void)
{
	pc_show_pointer();

	do
	{
		if (kbhit())
		{
			pc_hide_pointer();
			return getkey();
		}
		pc_poll_mouse(&gl_xmouse, &gl_ymouse, &gl_mbutton);
		if (gl_mbutton) 
		{
			pc_hide_pointer();
			return K_MOUSE;
		}
		idle();
	}
	while(1);
	return -1;
}


void putstatus(const char *s)
{
	switch(gl_graphics)
	{
		case MDA: mda_putstr(0, 0, s, 40, 0x09); 
			  mda_putstr(0,40, "", 40, 0x09); break;
		case CGA: cga_putstr(0, 0, s, 40, 0xFF, 7); break;
		case VGA: vga_putstr(0, 0, s, 40, 0, 15, 7); break;
	}
}

static byte cellshapes_mda[] = 
{
	' ', ' ',
	HLINE, HLINE,
	'*', '*',
	0xC4, 0x10,
	VLINE, ' ',
	TLJ,  HLINE,
	TRJ,  ' ',
	BLJ,  HLINE,
	BRJ,  ' ',
	0xB0, 0xB0,
	TJ,   HLINE,
	BJ,   HLINE,
	LJ,   ' ',
	RJ,   HLINE,
	XROADS, HLINE,
	STOPT,   ' ',
	STOPB,   ' ',
	STOPL,   ' ',
	STOPR,   HLINE,

};

#define MAXCELL_MDA ((sizeof(cellshapes_mda) / 2))

void drawcell_mda(unsigned r, unsigned c, unsigned type, int hilite, 
		unsigned base)
{
	byte far *data = MK_FP(0xB000, ((r+1) * 160) + (4 * c));
	byte attr = hilite ? 0x07 : 0x70;	
	char txt[3];

	sprintf(txt, "%02x", type);
	if (base >= 0x7EC7) sprintf(txt, "BB");
	else if (base >= 0x7DC7) sprintf(txt, "KK");
	else if (base >= 0x7CC7) sprintf(txt, "HH");
	else if (type < MAXCELL_MDA)
	{
		sprintf(txt, "%-2.2s", cellshapes_mda + 2 * type);
	}
	data[0] = txt[0];
	data[1] = attr;
	data[2] = txt[1];
	data[3] = attr;
}


void drawcell_cga(unsigned r, unsigned c, unsigned type, int hilite, 
		unsigned base)
{
	int y, yo;
	byte fg = hilite ? 0xAA : 0x55;
	byte bg = hilite ? 0x00 : 0xFF;

	byte far *data = MK_FP(0xB800, ((r+1) * 320) + (2 * c));
	unsigned cell = (type * 8) + base;

	if (base >= 0x7CC7) 
	{
	       	fg = hilite ? 0x55 : 0xAA; 
	}
	else switch(type)
	{
		case 2: fg = hilite ? 0x55 : 0xAA; break;
		case 3: fg = hilite ? 0xFF : 0x00; break;
		case 9: bg = hilite ? 0x22 : 0xEE; break;
	}

	for (yo = y = 0; y < 8; y++)
	{
		byte bits  = peek(cell + y);
		byte left  = cga_nibble[(bits >> 4) & 0x0F];
		byte right = cga_nibble[bits & 0x0F];

		data[yo    ] = (left  & fg) | (~left  & bg);
		data[yo + 1] = (right & fg) | (~right & bg);

		if (type == 9) bg ^= 0xFF;
		if (y & 1) yo += 80;
		yo ^= 0x2000;
	}
}


void drawcell_vga(unsigned r, unsigned c, unsigned type, int hilite,
		unsigned base)
{
	int y, x;
	byte fg;
	byte bg = 0x0f;

	byte far *data = MK_FP(0xA000, ((r+1) * 2560) + (8 * c));
	unsigned cell = (type * 8) + base;

	if (base >= 0x7EC7) 
	{
	       	fg = 4;
	}
	else if (base >= 0x7DC7) 
	{
	       	fg = 5;
	}
	else if (base >= 0x7CC7) 
	{
	       	fg = 1;
	}
	else switch(type)
	{
		case 2:  fg = 10; break;
		case 3:  fg =  0; break;
		case 9:  bg = 14; break;
		default: fg = 11; break;
	}

	if (hilite)
	{
		fg = ((~(fg & 7)) & 7) | (fg & 8);
		bg = ((~(bg & 15)) & 15);
	}

	for (y = 0; y < 8; y++)
	{
		byte mask = 0x80;
		byte bits  = peek(cell + y);

		for (x = 0; x < 8; x++)
		{
			data[y*320+x] = (bits & mask) ? fg : bg;
			mask = mask >> 1;
		}
	}
}


void drawcell(int r, int c, unsigned type, int attr)
{
	switch(gl_graphics)
	{
		case MDA: drawcell_mda(r, c, type, attr, tiles()); break;
		case CGA: drawcell_cga(r, c, type, attr, tiles()); break;
		case VGA: drawcell_vga(r, c, type, attr, tiles()); break;
	}
}


void drawsprite(int r, int c, unsigned bitmap, int attr)
{
	int x, y, t;

	t = 0;
	for (y = 0; y < 2; y++) for (x = 0; x < 2; x++)
	{
		switch(gl_graphics)
		{
			case MDA: drawcell_mda(y+r, x+c, t++, attr, bitmap); 
				  break;
			case CGA: drawcell_cga(y+r, x+c, t++, attr, bitmap);
				  break;
			case VGA: drawcell_vga(y+r, x+c, t++, attr, bitmap);
				  break;
		}
	}
}




void mda_cls(void)
{
	byte far *data = MK_FP(0xB000, 0);
	unsigned r, c;	
	byte ch, at;

	for (r = 0; r < 25; r++)
	{
		ch = r ? 0xb1 : 0x20;
		at = r ? 0x71 : 7;
		for (c = 0; c < 80; c++)
		{
			*data++ = ch;
			*data++ = at;	
		}
	}
	rectangle(279, 23, 26, 83, 0);
	mda_putstr( 2, 71, "Tile", -1, 15);
	mda_putstr( 3, 72, "\036\036",      -1, 15);
	mda_putstr( 8, 70, "\020    \021",  -1, 15);
	mda_putstr(12, 72, "\037\037",      -1, 15);
}


void cga_cls(void)
{
	byte far *data = MK_FP(0xB800, 0);
	unsigned r, c, offset;
	byte ik;

	for (r = 0; r < 200; r++)
	{
		if (r < 7) 
		{
			ik = 0xFF;
		}
		else if (r == 7)
		{
			ik = 0;
		}
		else 
		{
			ik = (r & 1) ? 0x66 : 0x99;
		}
		for (c = 0; c < 80; c++)
		{
			data[offset+c] = ik;
		}
		offset ^= 0x2000;
		if (r & 1) offset += 80;
	}
	rectangle(279, 22, 26, 84, 0);
	rectangle(280, 23, 24, 82, 0xff);
	cga_putstr(8, 35, "\020 \021", -1, 0xff, 8);
	cga_putstr(3, 36, "\036",      -1, 0xff, 7);
	cga_putstr(12, 36, "\037",      -1, 0xff, 7);
	rectangle(256, 8, 1, 192, 0);
}


void vga_cls(void)
{
	byte far *data = MK_FP(0xA000, 0);
	unsigned r, c;
	byte ik, mk;

	for (r = 0; r < 200; r++)
	{
		if (r < 7) 
		{
			ik = 15; mk = 0;
		}
		else if (r == 7)
		{
			ik = 0; mk = 0;
		}
		else 
		{
			ik = (r & 1) ? 9 : 15;
			mk = 9 ^ 15;
		}
		for (c = 0; c < 320; c++)
		{
			*data++ = ik;
			ik ^= mk;
		}
	}
	rectangle(279, 22, 26, 84, 0);
	rectangle(280, 23, 24, 82, 15);
	vga_putstr(8,  35, "\020 \021", -1, 1, 15, 8);
	vga_putstr(3,  36, "\036",      -1, 1, 15, 7);
	vga_putstr(12, 36, "\037",      -1, 1, 15, 7);
	rectangle(256, 8, 1, 192, 0);
}


void cls(void)
{
	switch(gl_graphics)
	{
		case MDA: mda_cls(); break;
		case CGA: cga_cls(); break;
		case VGA: vga_cls(); break;
	}
}


void mda_rect(unsigned x, unsigned y, unsigned w, unsigned h, unsigned attr)
{
	byte far *data =MK_FP(0xB000, 0);
	int r, c;
	byte fill[3];

	w = ((x + w + 7) / 8) - (x / 8);
	h = ((y + h + 7) / 8) - (y / 8);
	x = (x / 8);
	y = (y / 8);

	for (r = y; r < y+h; r++)
	{
		if (r == y) 
		{ 
			fill[0] = TLJ; fill[1] = HLINE; fill[2] = TRJ; 
		}
		else if (r == (y+h-1))
		{
			fill[0] = BLJ; fill[1] = HLINE; fill[2] = BRJ; 
		}
		else
		{
			fill[0] = VLINE; fill[1] = ' '; fill[2] = VLINE;
		}
		for (c = x; c < x+w; c++)
		{
			if (c == x)
			{
				data[r*160+2*c  ] = fill[0];
			}
			else if (c == (x+w-1))
			{
				data[r*160+2*c  ] = fill[2];
			}
			else data[r*160+2*c  ] = fill[1];
			data[r*160+2*c+1] = 15;	
		}
	}
}


void cga_rect(unsigned x, unsigned y, unsigned w, unsigned h, unsigned fill)
{
	byte far *data =MK_FP(0xB800, 0);
	int y1, x1;
	int offset, ptr;
	byte mask;

	for (y1 = 0; y1 < h; y1++)
	{
		offset = ((y + y1) & ~1) * 40;
		offset += ((y + y1) & 1) * 0x2000;
		for (x1 = x; x1 < (x+w); )
		{
			ptr = offset + (x1 / 4);
			/* Whole byte */
			if (((x1 & 3) == 0) && (x + w - x1) >= 4)
			{
				data[ptr] = fill;
				x1 += 4;
				continue;
			}
			/* Part byte */
			mask = 0xC0 >> (2 * (x1 & 3));
			data[ptr] &= ~mask;
			data[ptr] |= (fill & mask);
			x1++;
		}
	}	
}

void vga_rect(unsigned x, unsigned y, unsigned w, unsigned h, unsigned fill)
{
	byte far *data =MK_FP(0xA000, (y*320)+x);

	for (y = 0; y < h; y++)
	{
		for (x = 0; x < w; x++)
			data[x] = fill;
		data += 320;
	}
}


void rectangle(unsigned x, unsigned y, unsigned w, unsigned h, unsigned fill)
{
	switch(gl_graphics)
	{
		case MDA: mda_rect(x*2, y, w*2, h, fill); break;
		case CGA: cga_rect(x, y, w, h, fill ? 0xFF : 0); break;
		case VGA: vga_rect(x, y, w, h, fill ? 0x0F : 0); break;
	}
}



void popup(const char *s)
{
	int w, maxw, h;
	int x, y, n, r, c;
	char buf[41];
	int sw = (gl_graphics == MDA) ? 80 : 40;

	w = maxw = 0;
	h = 1;
	n = 0;
	while (s[n])
	{
		if (s[n] == '\n')
		{
			++h;
			if (w > maxw) maxw = w;
			w = 0;
		}
		else ++w;
		++n;
	}
	if (w < maxw) w = maxw;
	w += 2;
	h += 2;
	x = (40 - w) / 2;
	y = (25 - h) / 2;

	rectangle(x * 8,   y * 8,   w * 8,   h * 8,   0);
	rectangle(x * 8+1, y * 8+1, w * 8-2, h * 8-2, 1);
	n = c = 0;
	r = y + 1;
	while (s[n])
	{
		if (s[n] != '\n')
		{
			buf[c++] = s[n++];
			continue;
		}
		buf[c] = 0;
		iputstr(r, (sw - strlen(buf)) / 2, buf);
		c = 0;
		r++;
		++n;
	}
	buf[c] = 0;
	iputstr(r, (sw - strlen(buf)) / 2, buf);
}


void mda_draw_displacement(unsigned r1, unsigned c1, unsigned r2, unsigned c2,
		int active)
{
	int r, c, hj;
	int dy = 1, dx = 1;
	unsigned offset;
	byte far *data = MK_FP(0xB000, 0);
	int attr = active ? 0x0f : 0x07;

	c1 *= 2;
	c2 *= 2;
	if (r2 < r1) dy = -1;
	if (c2 < c1) dx = -1;

	hj = (dy < 0) ? 0 : 2;

	for (r = r1; r != r2; r += dy)
	{
		offset = (r + 1) * 160 + c1 * 2 + hj;
		data[offset] = VLINE2;
		data[offset+1] = attr;
	}
	if (c1 != c2)
	{
		/* The bend in the pipe */
		offset = (r2 + 1) * 160 + c1 * 2 + hj;
		if      (dy < 0 && dx > 0) data[offset] = TLJ2;
		else if (dy < 0 && dx < 0) data[offset] = TRJ2;
		else if (dy > 0 && dx > 0) data[offset] = BLJ2;
		else                       data[offset] = BRJ2;
		data[offset+1] = attr;

		for (c = c1 + dx; c != c2; c += dx)
		{
			offset = (r2 + 1) * 160 + c * 2 + hj;
			data[offset] = HLINE2;
			data[offset+1] = attr;
		}
	}
	offset = (r1 + 1) * 160 + c1 * 2 + hj;
	data[offset] = 7;	/* Start of teleport */
	data[offset+1] = attr;
	offset = (r2 + 1) * 160 + c2 * 2 + hj;
	if (c1 == c2)
	{
		data[offset] = (dy < 0) ? 0x18 : 0x19;
	}
	else
	{
		data[offset] = (dx < 0) ? 0x1b : 0x1a;
	}
	data[offset+1] = attr;
}


void vga_draw_displacement(unsigned r1, unsigned c1, unsigned r2, unsigned c2,
		int active)
{
	int r, c, hj;
	int dy = 1, dx = 1;
	int fg = active ? 12 : 4;
	unsigned offset;
	byte far *data = MK_FP(0xA000, 0);

	r1 *= 8; r1 += 4;
	r2 *= 8; r2 += 4;
	c1 *= 8;
	c2 *= 8;
	if (r2 < r1) dy = -1;
	if (c2 < c1) dx = -1;

	hj = (dy < 0) ? 3 : 6;

	for (r = r1; r != r2; r += dy)
	{
		offset = (r + 8) * 320 + c1 + hj;
		data[offset] = fg;
	}
	for (c = c1; c != c2; c += dx)
	{
		offset = (r2 + 8) * 320 + c + hj;
		data[offset] = fg;
	}
	offset = (r1 + 8) * 320 + c1 + hj;
/* Draw little blob round source */
	data[offset - 321] = fg; data[offset + 321] = fg;
	data[offset - 320] = fg; data[offset + 320] = fg;
	data[offset - 319] = fg; data[offset + 319] = fg;
	data[offset - 1] = fg; data[offset + 1] = fg;

/* Arrowhead */

	offset = (r2 + 8) * 320 + c2 + hj;
	if (c1 == c2 && r1 != r2)
	{
		if (dy < 0) 
		{ 
			data[offset+639] = data[offset+641] = fg;
			data[offset+959] = data[offset+961] = fg;
			data[offset+958] = data[offset+962] = fg;
		}
		else
		{
			data[offset-639] = data[offset-641] = fg;
			data[offset-959] = data[offset-961] = fg;
			data[offset-958] = data[offset-962] = fg;
		}
	}
	else if (c1 != c2)
	{
		if (dx < 0)
		{
			data[offset - 318] = data[offset + 322] = fg;
			data[offset - 317] = data[offset + 323] = fg;
			data[offset - 637] = data[offset + 643] = fg;
		}
		else
		{
			data[offset - 322] = data[offset + 318] = fg;
			data[offset - 323] = data[offset + 317] = fg;
			data[offset - 643] = data[offset + 637] = fg;
		}
	}
}



void cga_draw_displacement(unsigned r1, unsigned c1, unsigned r2, unsigned c2,
		int active)
{
	unsigned x1, y1, x2, y2, w, h;
	int hj;
	int dy = 1, dx = 1;
	byte fg = active ? 0xAA : 0;

	r1 *= 8; r1 += 12;
	r2 *= 8; r2 += 12;
	c1 *= 8;
	c2 *= 8;
	if (r2 < r1) 
	{
		y1 = r2;
		y2 = r2;
		dy = -1; 
		h = r1 - r2 + 1; 
	} 
	else 
	{
		y1 = r1;
		y2 = r2;
		h = r2 - r1 + 1; 
	}
	if (c2 < c1) 
	{
		x2 = c2;
		x1 = c1;
		dx = -1;
		w = c1 - c2 + 1; 
	} 
	else 
	{
		x1 = c1;
		x2 = c1;
		w = c2 - c1 + 1; 
	}

	hj = (dy < 0) ? 3 : 6;
	c1 += hj;
	c2 += hj;
	x1 += hj;
	x2 += hj;

	if (r1 != r2)
	{
		cga_rect(x1, y1, 1, h, fg);
	}
	if (c1 != c2)
	{
		cga_rect(x2, y2, w, 1, fg);
	}
	/* Source blob */
	cga_rect(c1 - 1, r1 - 1, 3, 3, fg);
	/* Target arrowhead */
	if (r1 == r2 && c1 == c2)
	{
		return;
	}
	if (c1 == c2)
	{
		if (r1 < r2)
		{
			cga_rect(c2 - 1, r2 - 1, 3, 1, fg);
			cga_rect(c2 - 2, r2 - 2, 5, 1, fg);
		}
		else
		{
			cga_rect(c2 - 1, r2 + 1, 3, 1, fg);
			cga_rect(c2 - 2, r2 + 2, 5, 1, fg);
		}
	}
	else
	{
		if (c1 < c2)
		{
			cga_rect(c2 - 1, r2 - 1, 1, 3, fg);
			cga_rect(c2 - 2, r2 - 2, 1, 5, fg);
		}
		else
		{
			cga_rect(c2 + 1, r2 - 1, 1, 3, fg);
			cga_rect(c2 + 2, r2 - 2, 1, 5, fg);
		}
	}
}

void draw_displacement(unsigned r1, unsigned c1, unsigned r2, unsigned c2,
		int active)
{
	int dy = 1, dx = 1;
	int r, c;

	if (r2 < r1) dy = -1;
	if (c2 < c1) dx = -1;

	switch(gl_graphics)
	{
		case MDA:
			mda_draw_displacement(r1, c1, r2, c2, active);
			break;
		case VGA:
			vga_draw_displacement(r1, c1, r2, c2, active);
			break;
		case CGA:
			cga_draw_displacement(r1, c1, r2, c2, active);
			break;

		default:	/* Fallback */
			for (r = r1; r != r2; r += dy)
			{
				putstr(r + 1, c1, "*", 0);
			}
			for (c = c1; c != c2; c += dx)
			{
				putstr(r2 + 1, c, "*", 0);
			}
			break;
	}
}

